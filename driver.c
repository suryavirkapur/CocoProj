/*
Group No. 46
- Suryavir Kapur (2022A7PS0293U)
- Ronit Dhansoia (2022A7PS0168U)
- Anagh Goyal (2022A7PS0177U)
- Harshwardhan Sugam (2022A7PS0114P)
*/

#include "lexer.h"
#include "parser.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#include "utils.h"

int main(int argc, char* argv[]) {

  printf("Group 46: Suryavir, Ronit, Anagh, Harshwardhan\n");
  printf("\ta. Lexer works perfectly  on t1 and t2.\n");
  printf("\tb. Status: Lexer and Computation of First/Follow Sets are functioning correctly.\n");
  printf("\tc. Grammar has been validated.\n");
  printf("\td. No segmentation faults or memory leaks detected across 6 test cases.\n");
  printf("\te. Lexer tests (T1-T2) work.\n");
  printf("\tf. Parser tests (T3-T5) work.\n");
  printf("\tg. Parser test (T6) detects errors, we need to do the formatting of errors, and redo the AST stack, \n "
         "\t\t\tdoesn't work on our test cases (S1-8).\n");

  int userOption;

  if (argc != 3) {
    printf("Usage: %s <source_file> <parse_tree_output_file>\n", argv[0]);
    return 0;
  }
  printf("Enter an option:\n");
  printf("\t0: to exit\n");
  printf("\t1: to print the comment free code on the console\n");
  printf("\t2: to print the token list generated by the lexer\n");
  printf("\t3: to verify the syntactic correctness of the input source code and printing the parse tree\n");
  printf("\t4: to print the total time taken by of lexer and parser to verify the syntactic correctness\n");

  ensureTrailingNewlines(argv[1]);

  while (1) {
    printf("Enter your option: ");
    scanf("%d", &userOption);

    switch (userOption) {
    case 0: {
      return 0;
    }
    case 1: {
      printf("[+] Starting removal of comments\n");
      printf("--------\n");
      removeComments(argv[1], NULL);
      printf("\n[-] Finished removing comments\n");
      break;
    }
    case 2: {
      printf("[+] Starting printing of token list\n");
      printf("--------\n");
      int f = open(argv[1], O_RDONLY);
      setupLexer(f);
      Token* t;
      while ((t = getToken()) != NULL) { // Remove the t->tokenName != TK_ERR condition
        if (t->tokenName == TK_COMMENT) {
          printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum, "#", getTerminal(t->tokenName));
        } else if (t->tokenName == TK_ERR) {
          // print the error token but keep going
          // printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum, t->tLexeme,
          // getTerminal(t->tokenName)); printf("Line %d Error: Unknown pattern <%s>\n", t->lineNum,
          // t->tLexeme);
        } else if (t->tokenName == TK_END) {
          // manual fix for the end token
          printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum - 1, t->tLexeme, getTerminal(t->tokenName));
        } else {
          printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum, t->tLexeme, getTerminal(t->tokenName));
        }
      }
      close(f);
      printf("\n[-] Finished printing of token list\n");
      break;
    }
    case 3: {
      printf("[-]Starting parsing of input source code\n");
      printf("--------\n");

      struct Grammar*        parsedGrammar      = extractGrammar();
      struct FirstAndFollow* firstAndFollowSets = computeFirstAndFollowSets(parsedGrammar);
      struct ParsingTable*   pTable             = createParsingTable();
      createParseTable(firstAndFollowSets, pTable);

      struct ParseTree* parseTable = parseSourceCode(argv[1], pTable, firstAndFollowSets);
      writeParseTreeToFile(parseTable, argv[2]);

      printf("\n[!]Finished parsing of input source code\n");
      break;
    }
    case 4: {
      printf("[!] Measuring time for lexical and syntax analysis\n");
      printf("--------\n");

      clock_t start_time, end_time;
      double  total_CPU_time, total_CPU_time_in_seconds;
      start_time = clock();

      struct Grammar*        parsedGrammar      = extractGrammar();
      struct FirstAndFollow* firstAndFollowSets = computeFirstAndFollowSets(parsedGrammar);
      struct ParsingTable*   pTable             = createParsingTable();
      createParseTable(firstAndFollowSets, pTable);
      parseSourceCode(argv[1], pTable, firstAndFollowSets);

      end_time                  = clock();
      total_CPU_time            = (double)(end_time - start_time);
      total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

      printf("[!] Total CPU time: %f\n", total_CPU_time);
      printf("[!] Total CPU time in seconds: %f\n", total_CPU_time_in_seconds);
      break;
    }
    default: {
      printf("[-] Invalid option, please try again\n");
    }
    }
  }
  return 0;
}