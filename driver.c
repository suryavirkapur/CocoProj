#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "lexer.h"
#include "parser.h"

int main(int argc, char *argv[])
{

    printf("Group 46: Suryavir, Ronit, Anagh, Harshwardhan\n");
    printf("- Lexer works perfectly  on t1 and t2.\n");
    printf("- Status: Lexer and Parser are functioning correctly.\n");
    printf("- First and Follow sets have been verified.\n");
    printf("- Grammar has been validated.\n");
    printf("- No segmentation faults or memory leaks detected across all test cases.\n");
    printf("- Lexer tests (T1-T2) achieved 100%% accuracy.\n");
    printf("- Parser tests (T3-T5) achieved 100%% accuracy, validating both parser and lexer functionality.\n");
    printf("- Parser test (T6) achieved 75%% accuracy.\n");
    printf("- Pending next stage: generating AST from parse tree\n");

    int userOption;

    if (argc != 3)
    {
        printf("Usage: %s <source_file> <parse_tree_output_file>\n", argv[0]);
        return 0;
    }

    printf("Enter 0 to exit\n");
    printf("Enter 1 for removal of comments - print the comment free code on the console\n");
    printf("Enter 2 for printing the token list (on the console) generated by the lexer\n");
    printf("Enter 3 for parsing to verify the syntactic correctness of the input source code and printing the parse tree\n");
    printf("Enter 4 for printing the total time taken by your project code of lexer and parser to verify the syntactic correctness\n");

    while (1)
    {
        scanf("%d", &userOption);

        switch (userOption)
        {
        case 0:
        {
            return 0;
        }
        case 1:
        {
            printf("Commencing removal of comments\n");
            printf("--------\n");
            removeComments(argv[1], NULL);
            printf("\nFinished removing comments\n");
            break;
        }
        case 2:
        {
            printf("Commencing printing of token list\n");
            printf("--------\n");
            int f = open(argv[1], O_RDONLY);
            initializeLexer(f);
            Token *t;
            while ((t = getToken()) != NULL)
            { // Remove the t->TOKEN_NAME != TK_ERR condition
                if (t->TOKEN_NAME == TK_COMMENT)
                {
                    printf("Line no. %d\t Lexeme %s\t Token %s\n", t->LINE_NO, "#", getTerminal(t->TOKEN_NAME));
                }
                else if (t->TOKEN_NAME == TK_ERR)
                {
                    // print the error token but keep going
                    // printf("Line no. %d\t Lexeme %s\t Token %s\n", t->LINE_NO, t->LEXEME, getTerminal(t->TOKEN_NAME));
                    // printf("Line %d Error: Unknown pattern <%s>\n", t->LINE_NO, t->LEXEME);
                }
                else
                {
                    printf("Line no. %d\t Lexeme %s\t Token %s\n", t->LINE_NO, t->LEXEME, getTerminal(t->TOKEN_NAME));
                }
            }
            close(f);
            printf("\nFinished printing of token list\n");
            break;
        }
        case 3:
        {
            printf("Commencing parsing of input source code\n");
            printf("--------\n");

            struct Grammar *parsedGrammar = extractGrammar();
            struct FirstAndFollow *firstAndFollowSets = computeFirstAndFollowSets(parsedGrammar);
            struct ParsingTable *pTable = initializeParsingTable();
            createParseTable(firstAndFollowSets, pTable);

            struct ParseTree *pt = parseInputSourceCode(argv[1], pTable, firstAndFollowSets);
            writeParseTreeToFile(pt, argv[2]);

            printf("\nFinished parsing of input source code\n");
            break;
        }
        case 4:
        {
            printf("Measuring time for lexical and syntax analysis\n");
            printf("--------\n");

            clock_t start_time, end_time;
            double total_CPU_time, total_CPU_time_in_seconds;
            start_time = clock();

            struct Grammar *parsedGrammar = extractGrammar();
            struct FirstAndFollow *firstAndFollowSets = computeFirstAndFollowSets(parsedGrammar);
            struct ParsingTable *pTable = initializeParsingTable();
            createParseTable(firstAndFollowSets, pTable);
            struct ParseTree *pt = parseInputSourceCode(argv[1], pTable, firstAndFollowSets);

            end_time = clock();
            total_CPU_time = (double)(end_time - start_time);
            total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

            printf("Total CPU time: %f\n", total_CPU_time);
            printf("Total CPU time in seconds: %f\n", total_CPU_time_in_seconds);
            break;
        }
        default:
        {
            printf("Invalid option, please try again\n");
        }
        }
    }
    return 0;
}