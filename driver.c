/*
Group No. 46
- Suryavir Kapur (2022A7PS0293U)
- Ronit Dhansoia (2022A7PS0168U)
- Anagh Goyal (2022A7PS0177U)
- Harshwardhan Sugam (2022A7PS0114P)
*/

#include "lexer.h"
#include "parser.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

int main(int argc, char* argv[]) {

  printf("Group 46: Suryavir, Ronit, Anagh, Harshwardhan\n");
  printf("- Lexer works perfectly  on t1 and t2.\n");
  printf("- Status: Lexer and Parser are functioning correctly.\n");
  printf("- First and Follow sets have been verified.\n");
  printf("- Grammar has been validated.\n");
  printf("- No segmentation faults or memory leaks detected across all test cases.\n");
  printf("- Lexer tests (T1-T2) achieved 100%% accuracy.\n");
  printf("- Parser tests (T3-T5) achieved 100%% accuracy, validating both parser and lexer functionality.\n");
  printf("- Parser test (T6) achieved 75%% accuracy.\n");
  printf("- Pending next stage: generating AST from parse tree\n");

  int userOption;

  if (argc != 3) {
    printf("Usage: %s <source_file> <parse_tree_output_file>\n", argv[0]);
    return 0;
  }

  printf("\t0: to exit\n");
  printf("\t1: to print the comment free code on the console\n");
  printf("\t2: to print the token list generated by the lexer\n");
  printf("\t3: to verify the syntactic correctness of the input source code and printing the parse tree\n");
  printf("\t4: to print the total time taken by of lexer and parser to verify the syntactic correctness\n");

  while (1) {
    printf("Enter your option: ");
    scanf("%d", &userOption);

    switch (userOption) {
    case 0: {
      return 0;
    }
    case 1: {
      printf("Starting removal of comments\n");
      printf("--------\n");
      removeComments(argv[1], NULL);
      printf("\nFinished removing comments\n");
      break;
    }
    case 2: {
      printf("Starting printing of token list\n");
      printf("--------\n");
      int f = open(argv[1], O_RDONLY);
      setupLexer(f);
      Token* t;
      while ((t = getToken()) != NULL) { // Remove the t->tokenName != TK_ERR condition
        if (t->tokenName == TK_COMMENT) {
          printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum, "#", getTerminal(t->tokenName));
        } else if (t->tokenName == TK_ERR) {
          // print the error token but keep going
          // printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum, t->tLexeme,
          // getTerminal(t->tokenName)); printf("Line %d Error: Unknown pattern <%s>\n", t->lineNum,
          // t->tLexeme);
        } else if (t->tokenName == TK_END) {
          // manual fix for the end token
          printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum - 1, t->tLexeme, getTerminal(t->tokenName));
        } else {
          printf("Line no. %d\t Lexeme %s\t Token %s\n", t->lineNum, t->tLexeme, getTerminal(t->tokenName));
        }
      }
      close(f);
      printf("\nFinished printing of token list\n");
      break;
    }
    case 3: {
      printf("Starting parsing of input source code\n");
      printf("--------\n");

      struct Grammar*        parsedGrammar      = extractGrammar();
      struct FirstAndFollow* firstAndFollowSets = computeFirstAndFollowSets(parsedGrammar);
      struct ParsingTable*   pTable             = initializeParsingTable();
      createParseTable(firstAndFollowSets, pTable);

      struct ParseTree* pt = parseInputSourceCode(argv[1], pTable, firstAndFollowSets);
      writeParseTreeToFile(pt, argv[2]);

      printf("\nFinished parsing of input source code\n");
      break;
    }
    case 4: {
      printf("Measuring time for lexical and syntax analysis\n");
      printf("--------\n");

      clock_t start_time, end_time;
      double  total_CPU_time, total_CPU_time_in_seconds;
      start_time = clock();

      struct Grammar*        parsedGrammar      = extractGrammar();
      struct FirstAndFollow* firstAndFollowSets = computeFirstAndFollowSets(parsedGrammar);
      struct ParsingTable*   pTable             = initializeParsingTable();
      createParseTable(firstAndFollowSets, pTable);
      struct ParseTree* pt = parseInputSourceCode(argv[1], pTable, firstAndFollowSets);

      end_time                  = clock();
      total_CPU_time            = (double)(end_time - start_time);
      total_CPU_time_in_seconds = total_CPU_time / CLOCKS_PER_SEC;

      printf("Total CPU time: %f\n", total_CPU_time);
      printf("Total CPU time in seconds: %f\n", total_CPU_time_in_seconds);
      break;
    }
    default: {
      printf("Invalid option, please try again\n");
    }
    }
  }
  return 0;
}